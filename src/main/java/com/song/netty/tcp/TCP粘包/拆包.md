TCP的粘包和拆包
TCP是一个流协议，所谓流，就是没有界限的一串数据；TCP底层并不了解上层业务的具体含义，它会根据TCP缓冲区的实际情况进行划分，所以在业务上理解，一个完整的包可能被TCP拆成多个包进行发送
也有可能把多个小的包鞥装成一个数据包进行传递，这就叫做TCP的粘包和拆包

TCP粘包和拆包发生的原因
1；应用程序的writei写入的字节大小大于套接字发送缓冲区的大小
2；进行MSS大小的TCP分段
3；以太网帧 payload大于MTU进行ip分片


粘包问题的解决策略

由于底层的TCP无法理解上层的业务数据，所以在底层无法保证数据不会被拆分以及重组，这个问题应该有上层应用协议栈的设计来解决
当前常用的方法是；
1；消息定长，如果不够空格补位
2；在包尾增加回车换行符进行分割
3；将消息氛围消息头与消息体，消息头中包含当前消息总长度的字段
4；更复杂的底层通讯协议



new StringDecoder()
    ;;将接收到的对象专程字符串，然后调用后面其他的handler

new LineBasedFrameDecoder(1024)
    ;;他的工作原理很简单，就是依次遍历ByteBuf中的可读字节，判读是否有"\n"或者"\r\n",如果有就以此作为结束位置，从可读索引到结束位置区间的字节就组成了一行数据
    它是以换行符为结束标志的解码器，支持携带结束符和不携带结束符的两种方式，
    支持配置单行最大长度；
                如果连续读到最大长度仍未出现换行结束符，就会抛出异常同时忽略掉之前已经读到的异常码流